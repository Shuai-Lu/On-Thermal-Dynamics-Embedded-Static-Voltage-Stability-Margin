function my_vsm_optimal()
% voltage security margin based on optimal regulation strategy of generation
%
%
% by Shuai Lu
% Southeast University
% shuai.lu.seu@outlook.com
% 2022-08-09


fprintf('%-40s\t\t', '- Optimal power flow');
t0 = clock;
global data model;

%%
num_period = data.options.num_period;
num_bus = size(data.grid.bus, 1);
num_branch = size(data.grid.branch, 1);
num_gen = size(data.grid.gen, 1);
num_load = sum(data.grid.bus(:,2) == 1);
indexset_load = find(data.grid.bus(:,2) == 1);
indexset_gen = find(data.grid.bus(:,2) > 1);

%%
model.vsm.obj = 0;
model.vsm.var = [];
model.vsm.cons = [];

%%
model.vsm.var.lambda = sdpvar(1, 1, 'full');
model.vsm.var.P = sdpvar(num_period, num_bus, 'full');
model.vsm.var.Q = sdpvar(num_period, num_bus, 'full');
model.vsm.var.U = sdpvar(num_period, num_bus, 'full');


model.vsm.var.theta = sdpvar(num_period, num_bus, 'full');
model.vsm.var.P_gen = sdpvar(num_period, num_gen, 'full');
model.vsm.var.Q_gen = sdpvar(num_period, num_gen, 'full');
model.vsm.var.P_gen_binary = sdpvar(num_period, num_gen, 'full');
model.vsm.var.U_gen_aux = sdpvar(num_period, num_gen, 2, 'full');

model.vsm.var.P_load = sdpvar(num_period, num_load, 'full');
model.vsm.var.Q_load = sdpvar(num_period, num_load, 'full');

model.vsm.var.cost_gen = sdpvar(num_period, num_gen, 'full');

%%
basekV = data.grid.bus(1,10);
baseMVA = 100;
[Ybus, Yf, Yt] = makeYbus(baseMVA, data.grid.bus, data.grid.branch);
Ybus = full(Ybus);
Gbus = real(Ybus);
Bbus = imag(Ybus);
% Yf = full(Yf);
% Yt = full(Yt);


%% Network
%% power flow
for i = 1 : num_bus
    model.vsm.cons = model.vsm.cons + (( ...
        model.vsm.var.P(:, i) == ...
        model.vsm.var.U(:, i) .* ( ...
        model.vsm.var.U(:, :) .* ...
        (cos(model.vsm.var.theta(:,i) * ones(1, num_bus) - model.vsm.var.theta(:,:))) * ...
        Gbus(:, i)  + ...
        model.vsm.var.U(:, :) .* ...
        (sin(model.vsm.var.theta(:,i) * ones(1, num_bus) - model.vsm.var.theta(:,:))) * ...
        Bbus(:, i))) : ...
        'P balance at bus');

    model.vsm.cons = model.vsm.cons + (( ...
        model.vsm.var.Q(:, i) == ...
        model.vsm.var.U(:, i) .* ( ...
        model.vsm.var.U(:, :) .* ...
        (sin(model.vsm.var.theta(:,i) * ones(1, num_bus) - model.vsm.var.theta(:,:))) * ...
        Gbus(:, i)  - ...
        model.vsm.var.U(:, :) .* ...
        (cos(model.vsm.var.theta(:,i) * ones(1, num_bus) - model.vsm.var.theta(:,:))) * ...
        Bbus(:, i))) : ...
        'Q balance at bus');
end

%% load bus
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P(:, indexset_load) * baseMVA == ...
    - model.vsm.var.P_load) : 'P at load bus');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.Q(:, indexset_load) * baseMVA == ...
    - model.vsm.var.Q_load) : 'Q at load bus');
%% gen bus
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P(:, indexset_gen) * baseMVA == ...
    model.vsm.var.P_gen): 'P at gen bus');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.Q(:, indexset_gen) * baseMVA == ...
    model.vsm.var.Q_gen): 'Q at gen bus');

%% bus phase
model.vsm.cons = model.vsm.cons + (( ...
    -pi/2 <= model.vsm.var.theta <= pi/2) : '-pi/2 <= Bus phase <=  pi/2');

%% slack bus
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.U(:,1) == 1.1) : 'Slack bus voltage = 1.1');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.theta(:,1) == 0) : 'Slack bus phase = 0');


%% bus voltage & Q of generator
model.vsm.cons = model.vsm.cons + (( ...
    0.9 <= model.vsm.var.U <= 1.1) : '0.9 <= Bus voltage <= 1.1');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.U_gen_aux(:) >= 0) : 'U_gen_aux >= 0');

model.vsm.cons = model.vsm.cons + (( ...
    ones(num_period, 1) * data.grid.gen(2:end,5)' <= ...
    model.vsm.var.Q_gen(:, 2:end) <= ...
    ones(num_period, 1) * data.grid.gen(2:end,4)') : 'Q_lower <= Q_gen <= Q_upper');

model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.U(:, indexset_gen(2:end)) == ...
    model.opf.var.U(:, indexset_gen(2:end)) + ...
    model.vsm.var.U_gen_aux(:, 2:end, 1) - ...
    model.vsm.var.U_gen_aux(:, 2:end, 2)) : 'U = U0 + U_gen_aux(1) - U_gen_aux(2)');

model.vsm.cons = model.vsm.cons + (( ...
    (ones(num_period, 1) * data.grid.gen(2:end,4)' - ...
    model.vsm.var.Q_gen(:, 2:end)) .* ...
    model.vsm.var.U_gen_aux(:, 2:end, 1) == 0) : '(Q_upper - Q_gen) * U_gen_aux(1) == 0');

model.vsm.cons = model.vsm.cons + (( ...
    (model.vsm.var.Q_gen(:, indexset_gen(2:end)) - ...
    ones(num_period, 1) * data.grid.gen(2:end,5)') .* ...
    model.vsm.var.U_gen_aux(:, 2:end, 2) == 0) : '(Q_gen - Q_gen) * U_gen_aux(2) == 0');


%% P of generator
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_gen(:, indexset_gen(2:end)) <= ...
    (1 + model.vsm.var.lambda) * ...
    model.opf.var.P_gen(:, indexset_gen(2:end))) : 'P_gen <= (1+lambda) * P_gen');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_gen(:, indexset_gen(2:end)) <= ...
    ones(num_period, 1) * data.grid.gen(2:end,9)') : 'P_gen <= P_upper');

model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_gen(:, indexset_gen(2:end)) >= ...
    (1 + model.vsm.var.lambda) * ...
    model.opf.var.P_gen(:, indexset_gen(2:end)) - ...
    data.param.big_M * ...
    model.vsm.var.P_gen_binary(:, indexset_gen(2:end))) : 'P_gen >= (1+lambda) * P_gen + M * binary');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_gen(:, indexset_gen(2:end)) >= ...
    ones(num_period, 1) * data.grid.gen(2:end,9)' - ...
    data.param.big_M * ...
    (1 - model.vsm.var.P_gen_binary(:, indexset_gen(2:end)))) : 'P_gen >= P_upper - M * (1-binary)');

model.vsm.cons = model.vsm.cons + (( ...
    0 <= model.vsm.var.P_gen_binary <= 1) : '0 <= binary <= 1');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_gen_binary == model.vsm.var.P_gen_binary .^2) : 'enforce to be binary');

%% load increase pattern
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.P_load == ...
    (1 + model.vsm.var.lambda) * ...
    data.grid.profiles.P_load) : 'P load increase pattern');
model.vsm.cons = model.vsm.cons + (( ...
    model.vsm.var.Q_load == ...
    (1 + model.vsm.var.lambda) * ...
    data.grid.profiles.Q_load) : 'Q load increase pattern');

% model.vsm.cons = model.vsm.cons + (( ...
%     model.vsm.var.lambda == 1.1));

%% Obj
model.vsm.var.cost_gen(:, :) = ...
    ones(num_period, 1) * data.grid.gencost(:, 5)' .* ...
    model.vsm.var.P_gen .^2 + ...
    ones(num_period, 1) * data.grid.gencost(:, 6)' .* ...
    model.vsm.var.P_gen + ...
    ones(num_period, 1) * data.grid.gencost(:, 7)';

% model.vsm.obj = sum(model.vsm.var.cost_gen(:));

model.vsm.obj = - model.vsm.var.lambda;

%% initialize
assign(model.vsm.var.U, ones(num_period, num_bus));

%% solve
model.vsm.ops = sdpsettings('solver', 'ipopt', 'verbose', 2, 'usex0', 1);
model.vsm.sol = optimize(model.vsm.cons, model.vsm.obj, model.vsm.ops);


if ~ model.vsm.sol.problem
    model.vsm = myFun_GetValue(model.vsm);
    fprintf('%s%.4f\n','Object: ', model.vsm.obj);
    fprintf('%s%.4f%s\n','solvertime: ', model.vsm.sol.solvertime,' s');
else
    fprintf('%s\n', model.vsm.sol.info);
end




%%
t1 = clock;
fprintf('%10.2f%s\n', etime(t1,t0), 's');

end